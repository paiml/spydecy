# Spydecy Quality Configuration
# EXTREME TDD with Zero Tolerance Quality Gates
# Inspired by Toyota Way, bashrs, and ruchy

[complexity]
# Transpiler-specific thresholds - EXTREME quality
cyclomatic_threshold = 10      # Max cyclomatic complexity per function
cognitive_threshold = 15       # Max cognitive complexity (human limit ~7)
max_nesting_depth = 4          # Shallow nesting for readability
max_function_lines = 80        # Short functions for testability
max_file_lines = 800           # Modular file organization
halstead_effort = 5000         # Max Halstead effort metric
maintainability_index = 70     # Min maintainability index (0-100 scale)

[entropy]
# Code duplication detection for transpiler patterns
enabled = true
min_pattern_occurrences = 12   # Detect repetitive IR conversion patterns
min_pattern_lines = 8          # Ignore trivial patterns
max_violations_to_report = 50  # Focus on significant duplication
pattern_similarity_threshold = 0.95  # High similarity for duplicates
ignore_test_files = true
ignore_generated_files = true
ignore_patterns = [
    "*/target/*",
    "*_test.rs",
    "*_tests.rs",
    "*/tests/*",
    "*.proptest-regressions",
    "*/examples/*",
    "*/fuzz/*",
]

[satd]
# ZERO TOLERANCE for technical debt comments (Self-Admitted Technical Debt)
enabled = true
zero_tolerance = true
patterns = [
    "TODO",
    "FIXME",
    "HACK",
    "XXX",
    "REFACTOR",
    "OPTIMIZE",
    "BUG",
    "KLUDGE",
    "WORKAROUND",
    "WIP",
    "TEMP",
]

# Exclusions for disabled code during development
[exclusions]
satd_paths = []  # No exclusions - zero tolerance everywhere
complexity_paths = []  # No exclusions - maintain complexity everywhere

[dead_code]
# Dead code detection with transpiler-specific rules
enabled = true
ignore_test_functions = true
ignore_cfg_test = true
threshold_percentage = 0.5  # Very strict - no dead code in transpiler

[coverage]
# Coverage requirements for safety-critical transpiler
minimum_coverage = 80.0      # Sprint 0-5: 80%, Sprint 10+: 85%
enforce_on_new_code = true
ignore_test_files = true
target_core_modules = [
    "crates/spydecy-python/src/",
    "crates/spydecy-c/src/",
    "crates/spydecy-hir/src/",
    "crates/spydecy-optimizer/src/",
    "crates/spydecy-codegen/src/",
]

[documentation]
# Documentation requirements for transpiler correctness
minimum_doc_coverage = 75.0  # Public API must be documented
require_examples = true      # All public functions need examples
require_safety_docs = true   # Safety-critical code requires docs
require_panic_docs = true    # Document panic conditions

[security]
# Security scanning for transpiler safety
enabled = true
scan_dependencies = true
check_unsafe_code = true
max_unsafe_blocks = 5        # Target: <5 per 1000 LOC
enforce_borrow_checker = true
check_memory_safety = true

[performance]
# Performance requirements for transpiler
enabled = true
max_transpile_time_ms = 100   # Target: <100ms for 10K LOC
max_memory_mb = 500           # Memory budget for transpilation
track_benchmarks = true

[quality_gate]
# Overall quality gate configuration - EXTREME TDD
fail_on_any_violation = false  # Use weighted scoring
aggregate_scoring = true
weights = {
    complexity = 0.30,       # High weight - complexity is critical
    entropy = 0.10,          # Moderate - some duplication acceptable
    satd = 0.25,             # High - zero tolerance policy
    dead_code = 0.15,        # Important - no unused code
    coverage = 0.15,         # Important - test everything
    documentation = 0.05     # Lower - focus on critical APIs
}

# Grade thresholds - EXTREME QUALITY
[grades]
a_plus = 98      # Perfection
a = 95           # Excellent
a_minus = 90     # Very good
b_plus = 85      # Good
b = 80           # Acceptable (minimum for merge)
b_minus = 75     # Needs improvement
c_plus = 70      # Warning
c = 65           # Poor
d = 55           # Critical
f = 0            # Unacceptable

[verification]
# Transpiler-specific verification requirements
enabled = true
check_correctness = true
check_determinism = true
check_idempotence = true

[mutation_testing]
# Mutation testing configuration
enabled = true
minimum_kill_rate = 0.90     # Target: â‰¥90% mutation kill rate
timeout_seconds = 300        # 5 minutes per mutant
smart_test_filtering = true  # Only run relevant tests per mutant
target_modules = [
    "spydecy-python",
    "spydecy-c",
    "spydecy-hir",
    "spydecy-optimizer",
]

[property_testing]
# Property-based testing requirements
enabled = true
minimum_properties = 100     # 100+ properties
cases_per_property = 1000    # 1000 cases per property = 100K+ total
timeout_per_property = 60    # 60 seconds max per property

[testing]
# General testing requirements
require_property_tests = true
require_doctests = true
require_examples = true
min_test_coverage = 80
require_integration_tests = true
require_e2e_tests = true

[benchmarks]
# Performance benchmarks
parser_speed = "50000"       # LOC/sec target
transpiler_speed = "25000"   # LOC/sec target
debugger_latency = "100"     # ms for step command

[toyota_way]
# Toyota Production System principles
jidoka = true               # Build quality in (zero defects)
hansei = true              # Reflection via Five Whys
kaizen = true              # Continuous improvement
genchi_genbutsu = true     # Go and see (dogfooding)

[ci]
# CI/CD configuration
fail_on_violation = true
generate_reports = true
block_merge_on_failure = true
run_property_tests = true
run_mutation_tests = true
upload_coverage = true

[rules]
# Additional quality rules
no_satd = true
max_line_length = 120
max_function_lines = 80
require_tests_for_new_code = true
